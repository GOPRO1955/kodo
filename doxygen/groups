
/// @defgroup fec FEC Layers
///  These layers contain the functionality needed to compose specific FEC codes e.g. Network Coding codes or Reed-Solomon codes.

/// @defgroup math Math Layers
/// Provides basic mathematical operations used in the coding operations.

/// @defgroup storage Storage Layers
/// Handle storage of coding symbols and implement different memory management strategies, depending on the needs of the applications.

/// @defgroup debug Debug Layers
///  Implements various debugging functionality. Typically useful when implementing new codes or when monitoring the performance of the coding algorithms.

/// @defgroup utility Utility Layers
/// Implementing various simple operations such as zero-initializing memory where needed. In addition to the added flexibility the use of C++ templates and parameterized inheritance allows the compiler to generate highly optimized code, with no need for virtual function dispatching etc.

/// @defgroup encoder_api Encoder API
/// These layers implement the following API:
/// \code
/// // @param symbol_data the memory buffer where the encoded symbol will
/// //        be stored
/// // @param symbol_id the memory buffer where the symbol id will
/// //        be stored
/// // @return the number of bytes used for the symbol id
/// uint32_t encode(uint8_t *symbol_data, uint8_t *symbol_id)
/// \endcode
///
/// If the layer manipulates the symbol id e.g. adding additional information
/// the layer must also implement the symbol_id_size() function to account
/// for the space needed.
///
/// \code
/// // @return the number of bytes used for the symbol id
/// uint32_t symbol_id_size() const
/// \endcode
///
/// The correct implementation of this function must take into account the
/// space requirements of the underlying layers. E.g. reserving 2 bytes for
/// a specific layer could be implemented as follows:
///
/// \code
/// template<class SuperCoder>
/// class my_custom_layer : public SuperCoder
/// {
/// public:
///
///     // ... some implementation
///
///     // @return the number of bytes used for the symbol id
///     uint32_t symbol_id_size() const
///     {
///         return 2 + SuperCoder::symbol_id_size();
///     }
///
/// };
/// \endcode
///
///
/// First Header  | Second Header
/// ------------- | -------------
/// Content Cell  | Content Cell
/// Content Cell  | Content Cell

