//
// LAYERS
//



/// @defgroup api_layer API Layers
/// @brief Provides an overview of the APIs implemented by different
/// components in Kodo.
///
/// Kodo is largely built using a C++ design technique called Mixin-Layers.
/// Mixin-Layers are a fexible way of seperating functionality into reusable
/// building blocks (called layers).
///
/// At each layer a seperate API is specified and in order to customize or
/// add functionality to Kodo it is necessary to understand which API
/// layer to look at.
///
/// @note That is by no means required that a specific encoder and
///       decoder utilize or provide all API layers. The API layers main
///       purpose is to facilitat re-use between implementations of
///       different encoders and decoders.
///
/// If you wish to get a better understanding the the layering techinique
/// used, you may take a look at the \ref mixin_example.
///
///
/// Before showing the typical layered structure of a encoder and decoder
/// implemented in Kodo is ...



//
// FACTORY
//



/// @defgroup factory Factory
/// @ingroup api_layer
/// @brief The factories are responsible for construction and
///        initialization of encoders and decoders.


/// @defgroup factory_api API
/// @ingroup factory
/// @brief The API used by factory layers.


/// @defgroup factory_layers Layers
/// @ingroup factory
/// @brief Implementations of the factory API.



//
// MATH
//



/// @defgroup math Finite Field Math
/// @ingroup api_layer
/// @brief The finite field math layers preform computations on symbols
///        and symbol coefficients.


/// @defgroup math_api API
/// @ingroup math
/// @brief The API used by math layers.
///
/// The prototype of a layer is the following:
///
/// @prototype


/// @defgroup math_layers Layers
/// @ingroup math
/// @brief Implementations of the math API.



//
// SYMBOL ID
//



/// @defgroup symbol_id Symbol IDs
/// @ingroup api_layer
/// @brief The symbol id describes how an encoded symbol has been produced.
///
/// The symbol id uniquely describes the coding coefficients which are used
/// by the encoder to create and encoded symbol as linear combinations of
/// a set of original source symbols. By transmitting the symbol id to the
/// decoder it can re-create the coding coefficients used to generate the
/// encoded symbol and by solving a linear system re-produce the original
/// source symbols.
/// @note In its simplest from the symbol id is the actual coding
///       coefficients. This type of symbol id is produced by the
///       \link kodo::random_uniform_symbol_id<SuperCoder>  class.
///       However for efficiency reasons you may want to limit the
///       amount of data transmitted between an encoder and decoder
///       by transmitting an smaller id.
///       One example of this is to use the \link seed_symbol_id
///       which only transmits the seed for the pseudo-random number
///       generator used to generate the coding coefficients.
///
///
/// @note In Network Coding applications the symbol id is often referred
///       to as the encoding vector.


/// @defgroup symbol_id_api API
/// @ingroup symbol_id
/// @brief The API used by symbol id layers.


/// @defgroup symbol_id_layers Layers
/// @ingroup symbol_id
/// @brief Implementations of the symbol id API.



//
// CODING INFO
//



/// @defgroup coding_info Coding Info
/// @ingroup api_layer
/// @brief Information about encoders and decoders


/// @defgroup coding_info_api API
/// @ingroup coding_info
/// @brief The coding information API.


//
// STORAGE API LAYERS
//


/// @defgroup storage Storage
/// @ingroup api_layer
/// @brief Handles storage of encoding and decoding symbols.

// SUB LAYER STORAGE INFO

/// @defgroup storage_info Storage Info
/// @ingroup storage
/// @brief Provides information about the symbol storage

/// @defgroup storage_info_api API
/// @ingroup storage_info
/// @brief The API used by storage info layers.

/// @defgroup storage_info_layers Layers
/// @ingroup storage_info
/// @brief Implementations of the storage info API.

// STORAGE SUB API LAYER: CONST SYMBOL ACCESS

/// @defgroup const_symbol_access Const Symbol Access
/// @ingroup storage
/// @brief Provides const access to the symbols storage

/// @defgroup const_symbol_access_api API
/// @ingroup const_symbol_access
/// @brief The const symbol access API is implemented by layers that
///        provide non modifiable memory access (const pointers) to
///        the stored symbols.

/// @defgroup const_symbol_access_layers Layers
/// @ingroup const_symbol_access
/// @brief Implementations of the const symbol access API.

// STORAGE SUB API LAYER: MUTABLE SYMBOL ACCESS

/// @defgroup mutable_symbol_access Mutable Symbol Access
/// @ingroup storage
/// @brief Provides mutable access to the symbols storage

/// @defgroup mutable_symbol_access_api API
/// @ingroup mutable_symbol_access
/// @brief The mutable symbol access API is implemented by layers that
///        provide non modifiable memory access (mutable pointers) to
///        the stored symbols.

/// @defgroup mutable_symbol_access_layers Layers
/// @ingroup mutable_symbol_access
/// @brief Implementations of the mutable symbol access API.

// STORAGE SUB API LAYER: CONST SYMBOL SOURCE

/// @defgroup const_symbol_source Const Symbol Source
/// @ingroup storage
/// @brief Provides const source to the symbols storage

/// @defgroup const_symbol_source_api API
/// @ingroup const_symbol_source
/// @brief The const symbol source API is implemented by layers that
///        provide non modifiable memory source (const pointers) to
///        the stored symbols.

/// @defgroup const_symbol_source_layers Layers
/// @ingroup const_symbol_source
/// @brief Implementations of the const symbol source API.

// STORAGE SUB API LAYER: MUTABLE SYMBOL SOURCE

/// @defgroup mutable_symbol_source Mutable Symbol Source
/// @ingroup storage
/// @brief Provides mutable source to the symbols storage

/// @defgroup mutable_symbol_source_api API
/// @ingroup mutable_symbol_source
/// @brief The mutable symbol source API is implemented by layers that
///        provide non modifiable memory source (mutable pointers) to
///        the stored symbols.

/// @defgroup mutable_symbol_source_layers Layers
/// @ingroup mutable_symbol_source
/// @brief Implementations of the mutable symbol source API.

// STORAGE SUB API LAYER: SYMBOL SWAP

/// @defgroup symbol_swap Symbol Swap
/// @ingroup storage
/// @brief The deep symbol source storage API is used by provide storage
///        the entire symbol buffer layers willstorage layers which
///        allocates and maintains the memory used encoders and decoders.

/// @defgroup symbol_swap_api API
/// @ingroup symbol_swap
/// @brief The swap symbol API is implemented by layers that allow the
///        symbol data in an encoder or decoder to be swapped.

/// @defgroup symbol_swap_layers Layers
/// @ingroup symbol_swap
/// @brief Implementations of the symbol swap API.

// STORAGE SUB API LAYER: SYMBOL STATUS

/// @defgroup symbol_status Symbol Status
/// @ingroup storage
/// @brief The symbol status API provides information about the available
///        symbols in the symbol storage.

/// @defgroup symbol_status_api API
/// @ingroup symbol_status
/// @brief The symbol status API.

/// @defgroup symbol_status_layers Layers
/// @ingroup symbol_status
/// @brief Implementations of the symbol status API.


//
// CODEC
//


/// @defgroup codec Codec
/// @ingroup api_layer
/// @brief Implements encoding and decoding algorithms.


/// @defgroup codec_api API
/// @ingroup codec
/// @brief The API used by encoding and decoding algorithms.
///
/// The prototype of a layer is the following:
///
/// @prototype


/// @defgroup codec_layers Layers
/// @ingroup codec
/// @brief Implementations of the codec API.


//
// CODEC HEADER
//



/// @defgroup codec_header Codec Header
/// @ingroup api_layer
/// @brief Implements header information to the coding symbols.


/// @defgroup codec_header_api API
/// @ingroup codec_header
/// @brief The API used by encoding and decoding algorithms.
///
/// The prototype of a layer is the following:
///
/// @prototype


/// @defgroup codec_header_layers Layers
/// @ingroup codec_header
/// @brief Implementations of the codec API.


//
// PAYLOAD
//

/// @defgroup payload_codec Payload Codec
/// @ingroup api_layer
/// @brief The payload layer provides users of an encoder or decoder with a
/// convenient API.
///
/// Creating a layer implementing the payload API makes it possible extend
/// encoders and decoders with functionality not neccesarily requiring direct
/// access to the symbol id and coded symbol.
///
/// The payload layer also provides a user of an encoder/decoder with a more
/// concenient API than the \ref coding_layer_api, which requires the user to
/// provided seperate buffers for the symbol id and symbol data. Using the
/// payload layer API the user only provides a single memory buffer, as shown
/// in the following example for an encoder:
///
/// \code
/// std::vector<uint8_t> payload(encoder->payload_size());
/// uint32_t bytes_used = encoder->encode(&payload[0]);
/// \endcode
///
/// Splitting the payload buffer
/// In order to use the payload layer one must also provide the
/// functionality to split the provided payload buffer into a
/// symbol header and symbol buffer, which are used by the
/// \ref codec_header_api.
///

/// @defgroup payload_codec_api API
/// @ingroup payload_codec
/// @brief The API used by payload codecs.

/// @defgroup payload_codec_layers Layers
/// @ingroup payload_codec
/// @brief Implementations of the codec API.
