\hypertarget{encode_on_the_fly_8cpp-example}{\section{encode\-\_\-on\-\_\-the\-\_\-fly.\-cpp}
}
This example shows how to use a storage aware encoder which will allow you to encode from a block before all symbols have been specified. This can be useful in cases where the symbols that should be encoded are produced on-\/the-\/fly.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Copyright Steinwurf ApS 2011-2012.}
\textcolor{comment}{// Distributed under the "STEINWURF RESEARCH LICENSE 1.0".}
\textcolor{comment}{// See accompanying file LICENSE.rst or}
\textcolor{comment}{// http://www.steinwurf.com/licensing}

\textcolor{preprocessor}{#include <kodo/rlnc/full\_vector\_codes.hpp>}
\textcolor{preprocessor}{#include <kodo/storage\_aware\_generator.hpp>}


\textcolor{keyword}{namespace }kodo
\{

    \textcolor{keyword}{template}<\textcolor{keyword}{class} Field>
    \textcolor{keyword}{class }on\_the\_fly\_encoder
        : \textcolor{keyword}{public} \textcolor{comment}{// Payload Codec API}
                 payload\_encoder<
                 \textcolor{comment}{// Codec Header API}
                 systematic\_encoder<
                 symbol\_id\_encoder<
                 \textcolor{comment}{// Symbol ID API}
                 plain\_symbol\_id\_writer<
                 \textcolor{comment}{// Coefficient Generator API}
                 storage\_aware\_generator<       \textcolor{comment}{// <--- New layer}
                 uniform\_generator<
                 \textcolor{comment}{// Codec API}
                 encode\_symbol\_tracker<
                 zero\_symbol\_encoder<
                 linear\_block\_encoder<
                 storage\_aware\_encoder<         \textcolor{comment}{// <--- New layer}
                 \textcolor{comment}{// Coefficient Storage API}
                 coefficient\_value\_access<
                 coefficient\_info<
                 \textcolor{comment}{// Symbol Storage API}
                 deep\_symbol\_storage<
                 storage\_bytes\_used<
                 storage\_block\_info<
                 \textcolor{comment}{// Finite Field API}
                 finite\_field\_math<typename fifi::default\_field<Field>::type,
                 finite\_field\_info<Field,
                 \textcolor{comment}{// Factory API}
                 final\_coder\_factory\_pool<
                 \textcolor{comment}{// Final type}
                 on\_the\_fly\_encoder<Field>
                     > > > > > > > > > > > > > > > > > >
    \{ \};
\}



\textcolor{keywordtype}{int} main()
\{
    \textcolor{comment}{// Set the number of symbols (i.e. the generation size in RLNC}
    \textcolor{comment}{// terminology) and the size of a symbol in bytes}
    uint32\_t symbols = 42;
    uint32\_t symbol\_size = 160;

    \textcolor{comment}{// Typdefs for the encoder/decoder type we wish to use}
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1on__the__fly__encoder}{kodo::on\_the\_fly\_encoder<fifi::binary8>} rlnc\_encoder;
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1full__rlnc__decoder}{kodo::full\_rlnc\_decoder<fifi::binary8>} rlnc\_decoder;

    \textcolor{comment}{// In the following we will make an encoder/decoder factory.}
    \textcolor{comment}{// The factories are used to build actual encoders/decoders}
    \hyperlink{classkodo_1_1payload__encoder_1_1factory}{rlnc\_encoder::factory} encoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} encoder = encoder\_factory.build();

    \hyperlink{classkodo_1_1payload__decoder_1_1factory}{rlnc\_decoder::factory} decoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} decoder = decoder\_factory.build();

    \textcolor{comment}{// Allocate some storage for a "payload" the payload is what we would}
    \textcolor{comment}{// eventually send over a network}
    std::vector<uint8\_t> payload(encoder->payload\_size());

    \textcolor{comment}{// Allocate some data to encode. In this case we make a buffer}
    \textcolor{comment}{// with the same size as the encoder's block size (the max.}
    \textcolor{comment}{// amount a single encoder can encode)}
    std::vector<uint8\_t> data\_in(encoder->block\_size());

    \textcolor{comment}{// Just for fun - fill the data with random data}
    \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &e: data\_in)
        e = rand() % 256;

    \textcolor{comment}{// Lets split the data into symbols and feed the encoder one symbol}
    \textcolor{comment}{// at a time}
    \textcolor{keyword}{auto} symbol\_storage =
        sak::split\_storage(sak::storage(data\_in), symbol\_size);

    \textcolor{keywordflow}{while}( !decoder->is\_complete() )
    \{
        \textcolor{comment}{// Encode a packet into the payload buffer}
        encoder->encode( &payload[0] );

        \textcolor{comment}{// Send the data to the decoders, here we just for fun}
        \textcolor{comment}{// simulate that we are loosing 50% of the packets}
        \textcolor{keywordflow}{if}((rand() % 2) == 0)
           \textcolor{keywordflow}{continue};

        \textcolor{comment}{// Packet got through - pass that packet to the decoder}
        decoder->decode( &payload[0] );

        \textcolor{comment}{// Randomly choose to insert a symbol}
        \textcolor{keywordflow}{if}((rand() % 2) == 0 && encoder->rank() < symbols)
        \{
            \textcolor{comment}{// For an encoder the rank specifies the number of symbols}
            \textcolor{comment}{// it has available for encoding}
            uint32\_t rank = encoder->rank();

            encoder->set\_symbol(rank, symbol\_storage[rank]);
        \}
    \}

    \textcolor{comment}{// The decoder is complete, now copy the symbols from the decoder}
    std::vector<uint8\_t> data\_out(decoder->block\_size());
    decoder->copy\_symbols(sak::storage(data\_out));

    \textcolor{comment}{// Check we properly decoded the data}
    \textcolor{keywordflow}{if} (std::equal(data\_out.begin(), data\_out.end(), data\_in.begin()))
    \{
        std::cout << \textcolor{stringliteral}{"Data decoded correctly"} << std::endl;
    \}
    \textcolor{keywordflow}{else}
    \{
        std::cout << \textcolor{stringliteral}{"Unexpected failure to decode "}
                  << \textcolor{stringliteral}{"please file a bug report :)"} << std::endl;
    \}

\}

\end{DoxyCodeInclude}
 