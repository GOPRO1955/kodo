\hypertarget{encode_recode_decode_simple_8cpp-example}{\section{encode\-\_\-recode\-\_\-decode\-\_\-simple.\-cpp}
}
In Network Coding applications one of the key features is the ability of intermediate nodes in the network to recode packets as they traverse them. In Kodo it is possible to recode packets in decoders which provide the recode() function.

This example shows how to use one encoder and two decoders to simulate a simple relay network as shown below (for simplicity we have error free links, i.\-e. no data packets are lost when being sent from encoder to decoder\-\_\-1 and decoder\-\_\-1 to decoder\-\_\-2)\-: \begin{DoxyVerb}    +-----------+      +-----------+      +------------+
    |  encoder  |+---->| decoder_1 |+---->|  decoder_2 |
    +-----------+      | (recoder) |      +------------+
                       +-----------+
\end{DoxyVerb}


In a practical application recoding can be using in several different ways and one must consider several different factors e.\-g. such as reducing linear dependency by coordinating several recoding nodes in the network. Suggestions for dealing with such issues can be found in current research litterature (e.\-g. M\-O\-R\-E\-: A Network Coding Approach to Opportunistic Routing).


\begin{DoxyCodeInclude}
\textcolor{comment}{// Copyright Steinwurf ApS 2011-2012.}
\textcolor{comment}{// Distributed under the "STEINWURF RESEARCH LICENSE 1.0".}
\textcolor{comment}{// See accompanying file LICENSE.rst or}
\textcolor{comment}{// http://www.steinwurf.com/licensing}


\textcolor{preprocessor}{#include <kodo/rlnc/full\_vector\_codes.hpp>}

\textcolor{keywordtype}{int} main()
\{
    \textcolor{comment}{// Set the number of symbols (i.e. the generation size in RLNC}
    \textcolor{comment}{// terminology) and the size of a symbol in bytes}
    uint32\_t symbols = 42;
    uint32\_t symbol\_size = 160;

    \textcolor{comment}{// Typdefs for the encoder/decoder type we wish to use}
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1full__rlnc__encoder}{kodo::full\_rlnc\_encoder<fifi::binary8>} 
      \hyperlink{classkodo_1_1full__rlnc__encoder}{rlnc\_encoder};
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1full__rlnc__decoder}{kodo::full\_rlnc\_decoder<fifi::binary8>} 
      \hyperlink{classkodo_1_1full__rlnc__callback__decoder}{rlnc\_decoder};

    \textcolor{comment}{// In the following we will make an encoder/decoder factory.}
    \textcolor{comment}{// The factories are used to build actual encoders/decoders}
    \hyperlink{classkodo_1_1payload__encoder_1_1factory}{rlnc\_encoder::factory} encoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} encoder = encoder\_factory.build();

    \hyperlink{classkodo_1_1payload__decoder_1_1factory}{rlnc\_decoder::factory} decoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} decoder\_1 = decoder\_factory.build();
    \textcolor{keyword}{auto} decoder\_2 = decoder\_factory.build();

    \textcolor{comment}{// Allocate some storage for a "payload" the payload is what we would}
    \textcolor{comment}{// eventually send over a network}
    std::vector<uint8\_t> payload(encoder->payload\_size());

    \textcolor{comment}{// Allocate some data to encode. In this case we make a buffer}
    \textcolor{comment}{// with the same size as the encoder's block size (the max.}
    \textcolor{comment}{// amount a single encoder can encode)}
    std::vector<uint8\_t> data\_in(encoder->block\_size());

    \textcolor{comment}{// Just for fun - fill the data with random data}
    \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &e: data\_in)
        e = rand() % 256;

    \textcolor{comment}{// Assign the data buffer to the encoder so that we may start}
    \textcolor{comment}{// to produce encoded symbols from it}
    encoder->set\_symbols(sak::storage(data\_in));

    \textcolor{keywordflow}{while}( !decoder\_2->is\_complete() )
    \{
        \textcolor{comment}{// Encode a packet into the payload buffer}
        encoder->encode( &payload[0] );

        \textcolor{comment}{// Pass that packet to decoder\_1}
        decoder\_1->decode( &payload[0] );

        \textcolor{comment}{// Now produce a new recoded packet from the current}
        \textcolor{comment}{// decoding buffer, and place it into the payload buffer}
        decoder\_1->recode( &payload[0] );

        \textcolor{comment}{// Pass the recoded packet to decoder\_2}
        decoder\_2->decode( &payload[0] );
    \}

    \textcolor{comment}{// Both decoder\_1 and decoder\_2 should now be complete,}
    \textcolor{comment}{// copy the symbols from the decoders}
    std::vector<uint8\_t> data\_out\_1(decoder\_1->block\_size());
    std::vector<uint8\_t> data\_out\_2(decoder\_2->block\_size());

    decoder\_1->copy\_symbols(sak::storage(data\_out\_1));
    decoder\_2->copy\_symbols(sak::storage(data\_out\_2));

    \textcolor{comment}{// Check we properly decoded the data}
    \textcolor{keywordflow}{if} (std::equal(data\_out\_1.begin(), data\_out\_1.end(), data\_in.begin()) &&
        std::equal(data\_out\_2.begin(), data\_out\_2.end(), data\_in.begin()))
    \{
        std::cout << \textcolor{stringliteral}{"Data decoded correctly"} << std::endl;
    \}
    \textcolor{keywordflow}{else}
    \{
        std::cout << \textcolor{stringliteral}{"Unexpected failure to decode "}
                  << \textcolor{stringliteral}{"please file a bug report :)"} << std::endl;
    \}
\}

\end{DoxyCodeInclude}
 