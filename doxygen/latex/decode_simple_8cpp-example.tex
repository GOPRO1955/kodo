\hypertarget{decode_simple_8cpp-example}{\section{decode\-\_\-simple.\-cpp}
}
It may be that we want to implement a new decoding algorithm in Kodo or simply just test an existing decoding implementation. In that case, it may be preferred to reuse functionalities in already existing layers while stripping functionalities that are not required to keep it simple.

This example illustrates how the operations of a R\-L\-N\-C decoder can be tested in a binary field without introducing unnecessary complexity. To keep it simple, we want to enter the data to be decoded ourself instead of relying on an encoder to generate the data. The functionalities in layers above the \char`\"{}\-Codec A\-P\-I\char`\"{} is therefore not required and has been stripped from the stack. However, the layers below the \char`\"{}\-Codec A\-P\-I\char`\"{} has been kept as they provide functionalities that are required.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Copyright Steinwurf ApS 2011-2013.}
\textcolor{comment}{// Distributed under the "STEINWURF RESEARCH LICENSE 1.0".}
\textcolor{comment}{// See accompanying file LICENSE.rst or}
\textcolor{comment}{// http://www.steinwurf.com/licensing}


\textcolor{preprocessor}{#include <cstdint>}
\textcolor{preprocessor}{#include <iostream>}
\textcolor{preprocessor}{#include <vector>}

\textcolor{preprocessor}{#include <kodo/rlnc/full\_vector\_codes.hpp>}
\textcolor{preprocessor}{#include <kodo/cached\_symbol\_decoder.hpp>}
\textcolor{preprocessor}{#include <kodo/debug\_cached\_symbol\_decoder.hpp>}
\textcolor{preprocessor}{#include <kodo/debug\_linear\_block\_decoder.hpp>}
\textcolor{preprocessor}{#include <kodo/debug\_coefficient\_storage.hpp>}
\textcolor{preprocessor}{#include <kodo/debug\_symbol\_storage.hpp>}

\textcolor{preprocessor}{#include <fifi/fifi\_utils.hpp>}

\textcolor{keyword}{namespace }kodo
\{
    \textcolor{comment}{// Simple RLNC decoder}
    \textcolor{keyword}{template}<\textcolor{keyword}{class} Field>
    \textcolor{keyword}{class }rlnc\_decoder
        : \textcolor{keyword}{public} \textcolor{comment}{// Decoder API}
                 debug\_cached\_symbol\_decoder<
                 cached\_symbol\_decoder<
                 debug\_linear\_block\_decoder<
                 forward\_linear\_block\_decoder<
                 symbol\_decoding\_status\_counter<
                 symbol\_decoding\_status\_tracker<
                 \textcolor{comment}{// Coefficient Storage API}
                 debug\_coefficient\_storage<
                 coefficient\_value\_access<
                 coefficient\_storage<
                 coefficient\_info<
                 \textcolor{comment}{// Storage API}
                 debug\_symbol\_storage<
                 deep\_symbol\_storage<
                 storage\_bytes\_used<
                 storage\_block\_info<
                 \textcolor{comment}{// Finite Field API}
                 finite\_field\_math<typename fifi::default\_field<Field>::type,
                 finite\_field\_info<Field,
                 \textcolor{comment}{// Factory API}
                 final\_coder\_factory\_pool<
                 \textcolor{comment}{// Final type}
                 rlnc\_decoder<Field>
                     > > > > > > > > > > > > > > > > >
    \{\};
\}


\textcolor{keywordtype}{int} main()
\{
    \textcolor{keyword}{typedef} fifi::binary field\_type;
    \textcolor{keyword}{typedef} field\_type::value\_type value\_type;

    \textcolor{comment}{// Set the number of symbols (i.e. the generation size in RLNC}
    \textcolor{comment}{// terminology) and the number of elements in a symbol}
    \textcolor{keyword}{const} uint32\_t symbols = 3;

    \textcolor{comment}{// 1 byte can store 8 finite field elements per symbol}
    \textcolor{keyword}{const} uint32\_t symbol\_size = 1;

    \textcolor{comment}{// Get the size, in bytes, of a coefficient vector}
    \textcolor{keyword}{const} uint32\_t coefficients\_size =
        fifi::elements\_to\_size<field\_type>(symbols);

    \textcolor{comment}{// Typdefs for the decoder type we wish to use}
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1rlnc__decoder}{kodo::rlnc\_decoder<field\_type>} rlnc\_decoder;

    \textcolor{comment}{// In the following we will make an decoder factory.}
    \textcolor{comment}{// The factory is used to build actual decoders}
    \hyperlink{classkodo_1_1payload__decoder_1_1factory}{rlnc\_decoder::factory} decoder\_factory(symbols, symbol\_size);
    rlnc\_decoder::pointer decoder = decoder\_factory.build();


    \textcolor{comment}{// To illustrate decoding, random data has been filled into the}
    \textcolor{comment}{// matrices below. It is crucial that the equation below is correct}
    \textcolor{comment}{// if the purpose is to test if the decoder decodes correctly as this}
    \textcolor{comment}{// example evaluates in the end of the example.}
    \textcolor{comment}{//}
    \textcolor{comment}{// For additional information, please see the article}
    \textcolor{comment}{//}
    \textcolor{comment}{//   Christina Fragouli, Jean-Yves Le Boudec, and JÃ¶rg Widmer.}
    \textcolor{comment}{//   Network Coding: An Instant Primer.}
    \textcolor{comment}{//   SIGCOMM Comput. Commun. Rev., 36(1):63-68, January 2006.}
    \textcolor{comment}{//}
    \textcolor{comment}{// from which the notation in the example is based on.}
    \textcolor{comment}{//}
    \textcolor{comment}{//}
    \textcolor{comment}{//}
    \textcolor{comment}{// original\_symbols (M):    Symbols we expect to obtain from decoding}
    \textcolor{comment}{//                          encoded\_symbols using the symbol\_coefficients.}
    \textcolor{comment}{// symbol\_coefficients (G): Coefficients used to encode/decode between}
    \textcolor{comment}{//                          original\_symbols and encoded\_symbols.}
    \textcolor{comment}{// encoded\_symbols (X):     Symbols that has been encoded from}
    \textcolor{comment}{//                          original\_symbols using the symbol\_coefficients.}
    \textcolor{comment}{//}
    \textcolor{comment}{//}
    \textcolor{comment}{//                          X = G M}
    \textcolor{comment}{//}
    \textcolor{comment}{//                        X^j = sum\_\{i=1\}^\{n\} g\_i^j M^i}
    \textcolor{comment}{//}
    \textcolor{comment}{//                |   X^1   |   | g^1\_1 g^1\_2 g^1\_3 | |   M^1   |}
    \textcolor{comment}{//                |   X^2   | = | g^2\_1 g^2\_2 g^2\_3 | |   M^2   |}
    \textcolor{comment}{//                |   X^3   |   | g^3\_1 g^3\_2 g^3\_3 | |   M^3   |}
    \textcolor{comment}{//}
    \textcolor{comment}{//       | encoded symbol 1 |   | encoding vect 1 | | original symbol 1 |}
    \textcolor{comment}{//       | encoded symbol 2 | = | encoding vect 2 | | original symbol 2 |}
    \textcolor{comment}{//       | encoded symbol 3 |   | encoding vect 3 | | original symbol 3 |}
    \textcolor{comment}{//}
    \textcolor{comment}{//        | 0 1 0 1 1 1 0 0 |   | 0 1 0 | | 1 1 1 0 1 1 0 1 |}
    \textcolor{comment}{//        | 1 0 1 1 0 0 0 1 | = | 1 1 0 | | 0 1 0 1 1 1 0 0 |}
    \textcolor{comment}{//        | 0 1 1 0 1 0 1 1 |   | 1 0 1 | | 1 0 0 0 0 1 1 0 |}
    \textcolor{comment}{//}
    \textcolor{comment}{// From the above matrix, the first encoded symbol is just the second}
    \textcolor{comment}{// original symbol M\_2. The second encoded symbol is M\_1 bitwise xor M\_2,}
    \textcolor{comment}{// and the third encoded symbol is M\_1 bitwise xor M\_3.}


    \textcolor{comment}{// The computer reads the bits in the opposite direction of how the}
    \textcolor{comment}{// elements are written matematically in the matrices above.}
    \textcolor{comment}{// Therefore, it may be easier to find the hex values, which we input into}
    \textcolor{comment}{// the variables below, if the matrices above are rewritten with the bits}
    \textcolor{comment}{// in the direction which they are stored in memory. This is shown in the}
    \textcolor{comment}{// matrices below:}
    \textcolor{comment}{//}
    \textcolor{comment}{//        | 0 0 1 1 1 0 1 0 |   | 0 1 0 | | 1 0 1 1 0 1 1 1 |}
    \textcolor{comment}{//        | 1 0 0 0 1 1 0 1 | = | 0 1 1 | | 0 0 1 1 1 0 1 0 |}
    \textcolor{comment}{//        | 1 1 0 1 0 1 1 0 |   | 1 0 1 | | 0 1 1 0 0 0 0 1 |}

    uint8\_t original\_symbols[] = \{ 0xb7, 0x3a, 0x61 \};
    uint8\_t symbol\_coefficients[] = \{ 0x02, 0x03, 0x05 \};
    uint8\_t encoded\_symbols[] = \{ 0x3a, 0x8d, 0xd6 \};

    std::cout << \textcolor{stringliteral}{"Start decoding..."} << std::endl << std::endl;

    \textcolor{comment}{// Decode each symbol and print the decoding progress}
    \textcolor{keywordflow}{for} (uint32\_t i = 0; i < symbols; ++i)
    \{
        \textcolor{comment}{// Pass the i'th symbol and coefficients to decoder}
        decoder->decode\_symbol(&encoded\_symbols[i*symbol\_size],
                &symbol\_coefficients[i*coefficients\_size]);

        std::cout << \textcolor{stringliteral}{"Coded symbol data:"} << std::endl;
        decoder->print\_cached\_symbol\_data(std::cout);

        std::cout << \textcolor{stringliteral}{"Coded symbol coefficients:"} << std::endl;
        decoder->print\_cached\_symbol\_coefficients(std::cout);

        std::cout << std::endl << \textcolor{stringliteral}{"Decoding matrix:"} << std::endl;
        decoder->print\_decoder\_state(std::cout);

        std::cout << \textcolor{stringliteral}{"Symbol matrix:"} << std::endl;
        decoder->print\_storage\_value(std::cout);
        std::cout << std::endl;
    \}

    \textcolor{comment}{// Ensure that decoding was completed successfully.}
    \textcolor{keywordflow}{if} (decoder->is\_complete())
    \{
        std::cout << \textcolor{stringliteral}{"Decoding completed"} << std::endl;
    \}
    \textcolor{keywordflow}{else}
    \{
        std::cout <<
            \textcolor{stringliteral}{"Decoding incomplete - not all encoding vectors are independent"} <<
            std::endl;
    \}

    \textcolor{comment}{// Copy decoded data into a vector}
    std::vector<uint8\_t> decoded\_symbols(decoder->block\_size());
    decoder->copy\_symbols(sak::storage(decoded\_symbols));

    \textcolor{comment}{// Check that the original data is the same as the decoded data}
    \textcolor{keywordflow}{if} (std::equal(decoded\_symbols.begin(), decoded\_symbols.end(),
        original\_symbols))
    \{
        std::cout << \textcolor{stringliteral}{"Data decoded correctly"};
    \}
    \textcolor{keywordflow}{else}
    \{
        std::cout << \textcolor{stringliteral}{"Error: Decoded data differs from original data"};
    \}
    std::cout << std::endl << std::endl;

\}
\end{DoxyCodeInclude}
 