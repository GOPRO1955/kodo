\hypertarget{switch_systematic_on_off_8cpp-example}{\section{switch\-\_\-systematic\-\_\-on\-\_\-off.\-cpp}
}
This example shows how to enable or disable systematic coding for coding stacks that support it. Systematic coding is used to reduce the amount of work done by an encoder and a decoder. This is achieved by initially sending all symbols which has not previously been sent uncoded. Kodo allows this feature to be optionally turn of or off.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Copyright Steinwurf ApS 2011-2013.}
\textcolor{comment}{// Distributed under the "STEINWURF RESEARCH LICENSE 1.0".}
\textcolor{comment}{// See accompanying file LICENSE.rst or}
\textcolor{comment}{// http://www.steinwurf.com/licensing}

\textcolor{preprocessor}{#include <kodo/rlnc/full\_vector\_codes.hpp>}


\textcolor{keywordtype}{int} main()
\{
    \textcolor{comment}{// Set the number of symbols (i.e. the generation size in RLNC}
    \textcolor{comment}{// terminology) and the size of a symbol in bytes}
    uint32\_t symbols = 16;
    uint32\_t symbol\_size = 160;

    \textcolor{comment}{// Typdefs for the encoder/decoder type we wish to use}
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1full__rlnc__encoder}{kodo::full\_rlnc\_encoder<fifi::binary8>} 
      \hyperlink{classkodo_1_1full__rlnc__encoder}{rlnc\_encoder};
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1full__rlnc__decoder}{kodo::full\_rlnc\_decoder<fifi::binary8>} 
      \hyperlink{classkodo_1_1full__rlnc__callback__decoder}{rlnc\_decoder};

    \textcolor{comment}{// In the following we will make an encoder/decoder factory.}
    \textcolor{comment}{// The factories are used to build actual encoders/decoders}
    \hyperlink{classkodo_1_1payload__encoder_1_1factory}{rlnc\_encoder::factory} encoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} encoder = encoder\_factory.build();

    \hyperlink{classkodo_1_1payload__decoder_1_1factory}{rlnc\_decoder::factory} decoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} decoder = decoder\_factory.build();

    \textcolor{comment}{// Allocate some storage for a "payload" the payload is what we would}
    \textcolor{comment}{// eventually send over a network}
    std::vector<uint8\_t> payload(encoder->payload\_size());

    \textcolor{comment}{// Allocate some data to encode. In this case we make a buffer}
    \textcolor{comment}{// with the same size as the encoder's block size (the max.}
    \textcolor{comment}{// amount a single encoder can encode)}
    std::vector<uint8\_t> data\_in(encoder->block\_size());

    \textcolor{comment}{// Just for fun - fill the data with random data}
    \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &e: data\_in)
        e = rand() % 256;

    \textcolor{comment}{// Assign the data buffer to the encoder so that we may start}
    \textcolor{comment}{// to produce encoded symbols from it}
    encoder->set\_symbols(sak::storage(data\_in));

    std::cout << \textcolor{stringliteral}{"Starting encoding / decoding"} << std::endl;

    \textcolor{keywordflow}{while}( !decoder->is\_complete() )
    \{
        \textcolor{comment}{// If the chosen codec stack supports systematic coding}
        \textcolor{keywordflow}{if}(\hyperlink{namespacekodo_a28819f1383e522581e8dc7fb351b0438}{kodo::is\_systematic\_encoder}(encoder))
        \{
            \textcolor{comment}{// With 50% probability toggle systematic}
            \textcolor{keywordflow}{if}((rand() % 2) == 0)
            \{
                \textcolor{keywordflow}{if}(\hyperlink{namespacekodo_a5ddd9632e1c9a2387bf15c81ad6c793b}{kodo::is\_systematic\_on}(encoder))
                \{
                    std::cout << \textcolor{stringliteral}{"Turning systematic OFF"} << std::endl;
                    \hyperlink{namespacekodo_a759a26580c7da7172657f338fd72a934}{kodo::set\_systematic\_off}(encoder);
                \}
                \textcolor{keywordflow}{else}
                \{
                    std::cout << \textcolor{stringliteral}{"Turning systematic ON"} << std::endl;
                    \hyperlink{namespacekodo_a949e0264c6b1b7ec1d4d71fe60160c32}{kodo::set\_systematic\_on}(encoder);
                \}
            \}
        \}

        \textcolor{comment}{// Encode a packet into the payload buffer}
        encoder->encode( &payload[0] );

        \textcolor{keywordflow}{if}((rand() % 2) == 0)
        \{
            std::cout << \textcolor{stringliteral}{"Drop packet"} << std::endl;
            \textcolor{keywordflow}{continue};
        \}

        \textcolor{comment}{// Pass that packet to the decoder}
        decoder->decode( &payload[0] );

        std::cout << \textcolor{stringliteral}{"Rank of decoder "} << decoder->rank() << std::endl;

        \textcolor{comment}{// Symbols that were received in the systematic phase correspond}
        \textcolor{comment}{// to the original source symbols and are therefore marked as}
        \textcolor{comment}{// decoded}
        std::cout << \textcolor{stringliteral}{"Symbols decoded "}
                  << decoder->symbols\_decoded() << std::endl;
    \}

    \textcolor{comment}{// The decoder is complete, now copy the symbols from the decoder}
    std::vector<uint8\_t> data\_out(decoder->block\_size());
    decoder->copy\_symbols(sak::storage(data\_out));

    \textcolor{comment}{// Check we properly decoded the data}
    \textcolor{keywordflow}{if} (std::equal(data\_out.begin(), data\_out.end(), data\_in.begin()))
    \{
        std::cout << \textcolor{stringliteral}{"Data decoded correctly"} << std::endl;
    \}
    \textcolor{keywordflow}{else}
    \{
        std::cout << \textcolor{stringliteral}{"Unexpected failure to decode "}
                  << \textcolor{stringliteral}{"please file a bug report :)"} << std::endl;
    \}
\}

\end{DoxyCodeInclude}
 