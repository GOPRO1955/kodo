\hypertarget{use_cached_symbol_decoder_8cpp-example}{\section{use\-\_\-cached\-\_\-symbol\-\_\-decoder.\-cpp}
}
This example shows how to use the cached symbol decoder to \char`\"{}extract\char`\"{} the symbol coding coefficients and the encoded symbol data from an incoming symbol.


\begin{DoxyCodeInclude}
\textcolor{comment}{// Copyright Steinwurf ApS 2011-2012.}
\textcolor{comment}{// Distributed under the "STEINWURF RESEARCH LICENSE 1.0".}
\textcolor{comment}{// See accompanying file LICENSE.rst or}
\textcolor{comment}{// http://www.steinwurf.com/licensing}

\textcolor{preprocessor}{#include <kodo/rlnc/full\_vector\_codes.hpp>}
\textcolor{preprocessor}{#include <kodo/cached\_symbol\_decoder.hpp>}
\textcolor{preprocessor}{#include <kodo/empty\_decoder.hpp>}

\textcolor{keyword}{namespace }kodo
\{

    \textcolor{keyword}{template}<\textcolor{keyword}{class} Field>
    \textcolor{keyword}{class }symbol\_info\_decoder
        : \textcolor{keyword}{public} \textcolor{comment}{// Payload API}
                 payload\_decoder<
                 \textcolor{comment}{// Codec Header API}
                 systematic\_decoder<
                 symbol\_id\_decoder<
                 \textcolor{comment}{// Symbol ID API}
                 plain\_symbol\_id\_reader<
                 \textcolor{comment}{// Decoder API}
                 cached\_symbol\_decoder<  \textcolor{comment}{// <-- Cached symbol decoder}
                 empty\_decoder<
                 \textcolor{comment}{// Coefficient Storage API}
                 coefficient\_info<
                 \textcolor{comment}{// Storage API}
                 storage\_bytes\_used<
                 storage\_block\_info<
                 \textcolor{comment}{// Finite Field API}
                 finite\_field\_info<Field,
                 \textcolor{comment}{// Factory API}
                 final\_coder\_factory\_pool<
                 \textcolor{comment}{// Final type}
                 symbol\_info\_decoder<Field>
                     > > > > > > > > > > >
    \{ \};

\}

\textcolor{keywordtype}{int} main()
\{
    \textcolor{comment}{// The finite field we will use in the example. You can try}
    \textcolor{comment}{// with other fields by specifying e.g. fifi::binary8 for the}
    \textcolor{comment}{// extension field 2^8}
    \textcolor{keyword}{typedef} fifi::binary finite\_field;

    \textcolor{comment}{// Set the number of symbols (i.e. the generation size in RLNC}
    \textcolor{comment}{// terminology) and the size of a symbol in bytes}
    uint32\_t symbols = 8;
    uint32\_t symbol\_size = 160;

    \textcolor{comment}{// Typdefs for the encoder/decoder type we wish to use}
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1full__rlnc__encoder}{kodo::full\_rlnc\_encoder<finite\_field>} rlnc\_encoder;
    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1full__rlnc__decoder}{kodo::full\_rlnc\_decoder<finite\_field>} rlnc\_decoder;

    \textcolor{keyword}{typedef} \hyperlink{classkodo_1_1symbol__info__decoder}{kodo::symbol\_info\_decoder<finite\_field>} 
      rlnc\_info\_decoder;

    \textcolor{comment}{// In the following we will make an encoder/decoder factory.}
    \textcolor{comment}{// The factories are used to build actual encoders/decoders.}
    \textcolor{comment}{// Each stack we use have their own factories.}
    \hyperlink{classkodo_1_1payload__encoder_1_1factory}{rlnc\_encoder::factory} encoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} encoder = encoder\_factory.build();

    \hyperlink{classkodo_1_1payload__decoder_1_1factory}{rlnc\_decoder::factory} decoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} decoder = decoder\_factory.build();

    rlnc\_info\_decoder::factory info\_decoder\_factory(symbols, symbol\_size);
    \textcolor{keyword}{auto} info\_decoder = info\_decoder\_factory.build();

    \textcolor{comment}{// Allocate some storage for a "payload" the payload is what we would}
    \textcolor{comment}{// eventually send over a network}
    std::vector<uint8\_t> payload(encoder->payload\_size());

    \textcolor{comment}{// Allocate some data to encode. In this case we make a buffer}
    \textcolor{comment}{// with the same size as the encoder's block size (the max.}
    \textcolor{comment}{// amount a single encoder can encode)}
    std::vector<uint8\_t> data\_in(encoder->block\_size());

    \textcolor{comment}{// Just for fun - fill the data with random data}
    \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} &e: data\_in)
        e = rand() % 256;

    \textcolor{comment}{// Assign the data buffer to the encoder so that we may start}
    \textcolor{comment}{// to produce encoded symbols from it}
    encoder->set\_symbols(sak::storage(data\_in));

    \textcolor{keywordflow}{while}( !decoder->is\_complete())
    \{
        \textcolor{comment}{// Encode a packet into the payload buffer}
        encoder->encode( &payload[0] );

        \textcolor{comment}{// Here we "simulate" a packet loss of approximately 50%}
        \textcolor{comment}{// by dropping half of the encoded packets.}
        \textcolor{comment}{// When running this example you will notice that the initial}
        \textcolor{comment}{// symbols are received systematically (i.e. uncoded). After}
        \textcolor{comment}{// sending all symbols once uncoded, the encoder will switch}
        \textcolor{comment}{// to full coding, in which case you will see the full encoding}
        \textcolor{comment}{// vectors being sent and received.}
        \textcolor{keywordflow}{if}((rand() % 2) == 0)
            \textcolor{keywordflow}{continue};

        \textcolor{comment}{// Pass the encoded packet to the info decoder. After this}
        \textcolor{comment}{// information about the coded symbol can be fetched using the}
        \textcolor{comment}{// cached\_symbol\_decoder API}
        info\_decoder->decode( &payload[0] );

        \textcolor{keywordflow}{if}(!info\_decoder->cached\_symbol\_coded())
        \{
            \textcolor{comment}{// The symbol was uncoded so we may ask the cache which of the}
            \textcolor{comment}{// original symbols we have received.}

            std::cout << \textcolor{stringliteral}{"Symbol was uncoded, index = "}
                      << info\_decoder->cached\_symbol\_index() << std::endl;

            \textcolor{comment}{// Now we pass the data directly into our actual decoder. This is}
            \textcolor{comment}{// done using the "Codec API" directly, and not through the "Payload}
            \textcolor{comment}{// API" as we would typically do.}
            decoder->decode\_symbol( info\_decoder->cached\_symbol\_data(),
                                    info\_decoder->cached\_symbol\_index());

        \}
        \textcolor{keywordflow}{else}
        \{
            \textcolor{comment}{// The symbol was coded so we may ask the cache to return}
            \textcolor{comment}{// the coding coefficients used to create the encoded symbol.}

            std::cout << \textcolor{stringliteral}{"Symbol was coded, encoding vector = "};

            \textcolor{keyword}{const} uint8\_t* c = info\_decoder->cached\_symbol\_coefficients();

            \textcolor{comment}{// We loop through the coefficient buffer and print the coefficients}
            \textcolor{keywordflow}{for}(uint32\_t i = 0; i < info\_decoder->symbols(); ++i)
            \{
                std::cout << (uint32\_t) fifi::get\_value<finite\_field>(c, i)
                          << \textcolor{stringliteral}{" "};
            \}

            std::cout << std::endl;

            \textcolor{comment}{// Pass that packet to the decoder, as with the uncoded symbols}
            \textcolor{comment}{// above we pass it directly to the "Codec API"}
            decoder->decode\_symbol(info\_decoder->cached\_symbol\_data(),
                                   info\_decoder->cached\_symbol\_coefficients());

        \}
    \}

    \textcolor{comment}{// The decoder is complete, now copy the symbols from the decoder}
    std::vector<uint8\_t> data\_out(decoder->block\_size());
    decoder->copy\_symbols(sak::storage(data\_out));

    \textcolor{comment}{// Check we properly decoded the data}
    \textcolor{keywordflow}{if} (std::equal(data\_out.begin(), data\_out.end(), data\_in.begin()))
    \{
        std::cout << \textcolor{stringliteral}{"Data decoded correctly"} << std::endl;
    \}
    \textcolor{keywordflow}{else}
    \{
        std::cout << \textcolor{stringliteral}{"Unexpected failure to decode "}
                  << \textcolor{stringliteral}{"please file a bug report :)"} << std::endl;
    \}
\}

\end{DoxyCodeInclude}
 